import numpy as np
import copy
import matplotlib.pyplot as plt
from testCases_v2 import *
from public_tests import *
import sklearn
import sklearn.datasets
import sklearn.linear_model

%matplotlib inline

%load_ext autoreload
%autoreload 2

I, O = load_planar_dataset()
shape_I = I.shape
shape_O = O.shape
training_sample_cnt = I.shape[1]

def NN_sizes(I, O):
  n_i = I.shape[0]
  n_h = 4
  n_o = Y.shape[0]

def init_parameters(n_i, n_h, n_o):
  W1 = np.random.randn(n_h,n_x) * 0.01
  b1 = np.zeros((n_h,1),dtype='float')
  W2 = np.random.randn(n_y,n_h) * 0.01
  b2 = np.zeros((n_y,1),dtype='float')

  pars = {"W1": W1,
          "b1": b1,
          "W2": W2,
          "b2": b2}

  return pars

def forward_prop(I, pars):
  Z1 = np.dot(pars["W1"], I) + pars["b1"]
  A1 = np.tanh(Z1)
  Z2 = np.dot(pars["W2"], I) + pars["b2"]
  A2 = 1 / (1 + np.exp(-Z2))    

  cache = {"Z1": Z1,
             "A1": A1,
             "Z2": Z2,
             "A2": A2}
    
  return A2, cache

def cost(A2, O):
  m = O.shape[1]
  cost = -( np.dot(Y, (np.log(A2)).T) + np.dot( (np.ones((Y.shape[0],Y.shape[1]), dtype=int) - Y.astype(int)), (np.log(np.ones((Y.shape[0],Y.shape[1]), dtype=int) - A2)).T))/m
  cost = float(np.squeeze(cost))
  return cost

def backward_prop(pars, cache, I, O):
  m = I.shape[1]
  dZ2 = cache["A2"] - O
  dW2 = np.dot(dZ2, cache["A1"].T) / m
  db2 = np.sum(dZ2, axis=1, keepdims=True) / m
  dZ1 = np.dot(pars["W2"] .T, dZ2) * (1 - np.power(cache["A1"], 2))
  dW1 = np.dot(dZ1, I.T) / m
  db1 = np.sum(dZ1, axis=1, keepdims=True) / m 

  gradients = {"dW1": dW1,
             "db1": db1,
             "dW2": dW2,
             "db2": db2}
    
  return gradients

def update_pars(pars, gradients, learning_rate = 1.0):
  W1 = copy.deepcopy(pars["W1"])
  b1 = pars["b1"]
  W2 = copy.deepcopy(pars["W2"])
  b2 = pars["b2"]
  dW1 = gradients["dW1"]
  db1 = gradients["db1"]
  dW2 = gradients["dW2"]
  db2 = gradients["db2"]    
  W1 = W1 - learning_rate * dW1
  b1 = b1 - learning_rate * db1
  W2 = W2 - learning_rate * dW2
  b2 = b2 - learning_rate * db2

  pars = {"W1": W1,
          "b1": b1,
          "W2": W2,
          "b2": b2}
    
  return pars

def model(I, O, n_h, num_iterations = 10000, print_cost=False):
  n_i = NN_sizes(I, O)[0]
  n_o = NN_sizes(I, O)[2]

  pars = init_parameters(n_i, n_h, n_o)

  for i in range(0, num_iterations):
    A2, cache = forward_prop(I, pars)
    cost = compute_cost(A2, O)
    gradients = backward_prop (pars, cache, I, O)
    pars = update_pars(pars, gradients)

  return pars







    


  
